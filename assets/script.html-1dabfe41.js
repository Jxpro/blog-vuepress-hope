import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as s,c as d,a as e,b as t,d as o,e as n}from"./app-5e6e2e94.js";const c={},l=n('<h1 id="比特币脚本及交易分析-智能合约雏形" tabindex="-1"><a class="header-anchor" href="#比特币脚本及交易分析-智能合约雏形" aria-hidden="true">#</a> 比特币脚本及交易分析 - 智能合约雏形</h1><ul><li><p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。 在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。 本文就来分析一下<strong>交易是如何实现可编程的</strong>。</p></li><li><p>当谈及智能合约时，大多数人都会下意识地把比特币排除在讨论范围之外，因为当下流行的观点是比特币不具有智能合约的能力。但是今天想跟大家介绍的内容则正好与此相反：即<strong>比特币从诞生之日即拥有支持智能合约的能力</strong></p></li></ul><h2 id="一、图灵不完备" tabindex="-1"><a class="header-anchor" href="#一、图灵不完备" aria-hidden="true">#</a> 一、图灵不完备</h2><blockquote><p>比特币脚本语言<strong>不是图灵完备的</strong>，具有一定的局限性，它<strong>没有循环语句和复杂的条件控制语句</strong>。由于语言存在这种局限性，我们也就没办法使用这种语言写一些死循环或者一些能够导致DOS攻击的恶意代码，从而也就<strong>避免了比特币网络受到DOS攻击</strong>。每一个全节点，都会对交易进行验证。具有这种局限性的脚本语言，使人们无法把这种验证机制看成一个攻击比特币网络的缺陷。</p></blockquote><h2 id="二、未花费的交易输出-utxo" tabindex="-1"><a class="header-anchor" href="#二、未花费的交易输出-utxo" aria-hidden="true">#</a> 二、未花费的交易输出(UTXO)</h2><p>比特币底层采用了一个很特别的交易模型设计，即 <strong>UTXO（Unspent Transaction Outputs）</strong> 模型。这里我们简单介绍一下，首先来看最基本的交易是如何表示的。</p><p>每一个比特币交易主要包括两部分：<strong>输入记录和输出记录</strong>。</p><p>每条输出记录主要包括的信息：</p><ul><li>此输出中包含的比特币数量；</li><li>一段脚本代码，通常称为<strong>锁定脚本</strong>；</li></ul><p>每条输入记录主要包括的信息：</p><ul><li>对前一个交易输出部分的引用；</li><li>一段脚本代码，通常称为<strong>解锁脚本</strong>；</li></ul><blockquote><p>假设有人已成功发给我一个比特币，那么在链上就存在一条历史交易记录 TX_1。它的输出记录中有一条（记为 <code>TX_1_OUT_1</code>）包含了数量为 1 的比特币以及一个只能由我的私钥才能“开启”的“锁”（锁定脚本）。也正是由于这把“锁”的存在，别人才无法使用这个比特币。</p><p>现在我想把这个比特币转给另外一个人，那么需要构建一个新的交易记录 TX_2。它的输入记录中包含了对之前交易输出 <code>TX_1_OUT_1</code> 的引用，以及一段由我的私钥签名过的“钥匙”（解锁脚本）；输出记录（记为 <code>TX_2_OUT_1</code>）中则包含了比特币数量 1，以及一个只有接收人才能“开启”的“锁”（另一个锁定脚本）。</p><p>这个新的交易 TX_2 被我发送给矿工，且只有通过了矿工对解锁脚本有效性的验证后，这笔交易才会被记录到链上账本中。此时也意味着我完成了一个接收+花费比特币的典型场景。</p><p>此时，输出 <code>TX_1_OUT_1</code> 由于被 TX_2 中的输入成功使用，会被系统被标记为已花出。如果尝试利用它再次构建交易，会被矿工认定为“双花”从而拒绝。与之相对，输出 <code>TX_2_OUT_1</code> 由于尚未被任何输入使用，故被称为未花费输出（即 UTXO）</p></blockquote><p>比特币的交易都是基于UTXO上的，即<strong>交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入</strong>。</p><blockquote><p>挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。 UTXO是交易的基本单元，不能再分割。 在比特币没有余额概念，只有分散到区块链里的UTXO</p></blockquote><p>随着钱从一个地址被移动到另一个地址的同时<strong>形成了一条所有权链</strong>，像这样： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-150721.jpeg!wl" alt="own_chain" loading="lazy"></p><h2 id="三、比特币脚本-script-及虚拟机-bvm" tabindex="-1"><a class="header-anchor" href="#三、比特币脚本-script-及虚拟机-bvm" aria-hidden="true">#</a> 三、比特币脚本（Script）及虚拟机（BVM）</h2>',16),p=e("code",null,"Script",-1),h=e("strong",null,"基于栈的脚本语言",-1),g={href:"https://wiki.bitcoinsv.io/index.php/Opcodes_used_in_Bitcoin_Script",target:"_blank",rel:"noopener noreferrer"},u=n(`<table><thead><tr><th>操作码</th><th>描述</th></tr></thead><tbody><tr><td>OP_2</td><td>将数值 <code>2</code> 推至栈顶</td></tr><tr><td>OP_ADD</td><td>将栈顶的两个元素数值相加</td></tr><tr><td>OP_EQUAL</td><td>如果栈顶上2个元素相等，则返回 <code>true</code>；否则返回 <code>false</code></td></tr></tbody></table><p>锁定脚本（位于前一个交易的输出中）和解锁脚本（位于当前交易的输入中）都是由其中一些操作码串联组成，每个操作码后面可以有零至两个操作子。</p><p>为了验证解锁脚本的有效性，**比特币虚拟机（BVM）**被引入比特币节点。BVM 将锁定脚本连接在解锁脚本的后面，从而形成完整的执行脚本。这个完整的脚本会被 BVM 执行。当执行完毕后，如果栈顶元素的布尔值为 <code>true</code>（即数值非零），则认为脚本执行成功，反之其他情况则认为脚本执行失败。</p><p>最为常见类型的比特币交易脚本（支付到公钥哈希：<strong>P2PKH（Pay-to-Public-Key-Hash）</strong>）如下： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151439.jpeg!wl" alt="script" loading="lazy"></p><h2 id="四、简单交易脚步举例" tabindex="-1"><a class="header-anchor" href="#四、简单交易脚步举例" aria-hidden="true">#</a> 四、简单交易脚步举例</h2><p>我们来看个例子。假设在一个交易中，一些比特币被使用以下脚本锁定在输出中：</p><div class="language-script line-numbers-mode" data-ext="script"><pre class="language-script"><code>OP_1 OP_2 OP_ADD OP_EQUAL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在另外一个试图花费这个输出的交易中，使用以下脚本：</p><div class="language-script line-numbers-mode" data-ext="script"><pre class="language-script"><code>OP_3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了说明这里的解锁授权是如何进行的，我们来分步模拟一下脚本的执行过程。</p><ul><li><p>首先，解锁脚本在前，锁定脚本在后，将两个脚本连接起来形成完整的脚本：</p><div class="language-script line-numbers-mode" data-ext="script"><pre class="language-script"><code>OP_3 OP_1 OP_2 OP_ADD OP_EQUAL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>接着，BVM 开始从头执行完整的脚本，具体的步骤如图所示：</p></li></ul><figure><img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-154148" alt="BVM执行过程" tabindex="0" loading="lazy"><figcaption>BVM执行过程</figcaption></figure><p>最终结束时留在栈顶上的唯一值为 <code>true</code>，这说明整个脚本执行成功。如果使用任何不是 <code>3</code> 的值作为解锁脚本，则整个脚本的执行结果必然为 <code>false</code>，意味着无法成功解锁。</p><h2 id="五、常见交易脚本验证过程" tabindex="-1"><a class="header-anchor" href="#五、常见交易脚本验证过程" aria-hidden="true">#</a> 五、常见交易脚本验证过程</h2><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言</p>`,15),_={href:"http://www.8btc.com/bitcoin_scripts",target:"_blank",rel:"noopener noreferrer"},m=n('<p>脚本语言通过<strong>从左至右</strong>地处理每个项目的方式执行脚本，下面用两个图说明下常见类型的比特币交易脚本验证执行过程：</p><ul><li>下图为<strong>解锁脚本</strong>运行过程（主要是<strong>入栈</strong>） <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151430.jpeg!wl" alt="script_run1" loading="lazy"></li><li>下图为<strong>锁定脚本</strong>运行过程（主要是<strong>出栈</strong>)，最后的结果为真，说明交易有效。 <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151455.jpeg!wl" alt="script_run2" loading="lazy"></li></ul><h2 id="六、交易分析" tabindex="-1"><a class="header-anchor" href="#六、交易分析" aria-hidden="true">#</a> 六、交易分析</h2><h3 id="_6-1-交易结构" tabindex="-1"><a class="header-anchor" href="#_6-1-交易结构" aria-hidden="true">#</a> 6.1 交易结构</h3><p>比特币的交易被设计为可以纳入<strong>多个输入和输出</strong><img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151808.jpeg!wl" alt="交易结构" loading="lazy"></p><blockquote><p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示<strong>立即执行</strong>。 如果锁定时间不是0并且小于5亿，就被视为<strong>区块高度</strong>，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。 如果锁定时间大于5亿，则它被当作是一个<strong>Unix纪元时间戳</strong>（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p></blockquote><blockquote><p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：<strong>交易费 = 求和（所有输入） - 求和（所有输出）</strong></p></blockquote><h3 id="_6-2-交易输入结构" tabindex="-1"><a class="header-anchor" href="#_6-2-交易输入结构" aria-hidden="true">#</a> 6.2 交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152040.jpeg!wl" alt="输入结构" loading="lazy"></p><p>我们结合整个交易的结构里看输入结构就是这样子： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152048.jpeg!wl" alt="输入结构1" loading="lazy"></p><h3 id="_6-3-交易输出结构" tabindex="-1"><a class="header-anchor" href="#_6-3-交易输出结构" aria-hidden="true">#</a> 6.3 交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-150709.jpeg!wl" alt="交易输出结构" loading="lazy"> 我们结合整个交易的结构里看输出结构就是这样子： <img src="https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152102.jpeg!wl" alt="交易输出结构1" loading="lazy"></p><h2 id="七、智能合约雏形" tabindex="-1"><a class="header-anchor" href="#七、智能合约雏形" aria-hidden="true">#</a> 七、智能合约雏形</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p><p>比特币的脚本目前常用的主要分为两种：</p><ul><li>一种是常见的<strong>P2PKH</strong>（支付给公钥哈希）</li><li>另一种是<strong>P2SH</strong>（Pay-to-Script-Hash支付脚本哈希）</li></ul><p>P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p><p>下面说明一些应用场景，以便大家有更直观的认识。</p><ul><li><strong>多重签名应用</strong> 合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</li><li><strong>保证合同</strong> 保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。 一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</li><li><strong>依靠预言</strong> 假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。 因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</li></ul><h2 id="八、参考文章" tabindex="-1"><a class="header-anchor" href="#八、参考文章" aria-hidden="true">#</a> 八、参考文章</h2>',20),b={href:"https://learnblockchain.cn/2017/11/10/bitcoin-script/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.infoq.cn/article/deep-understanding-of-bitcoin-transaction-script/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/freedomhero/article/details/106801904",target:"_blank",rel:"noopener noreferrer"};function P(O,w){const r=i("ExternalLinkIcon");return s(),d("div",null,[l,e("p",null,[t("比特币底层使用一种名为"),p,t("的脚本语言来实现“锁”和“钥匙”，它是一种"),h,t("。简单来说，它是一串由操作码（opcode）组成的指令集合，下面是几个简单的操作码例子：（完整的操作码列表请参考"),e("a",g,[t("这里"),o(r)]),t("）")]),u,e("blockquote",null,[e("p",null,[t("比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:"),e("a",_,[t("比特币脚本"),o(r)])])]),m,e("ul",null,[e("li",null,[e("a",b,[t("比特币脚本及交易分析 - 智能合约雏形"),o(r)])]),e("li",null,[e("a",f,[t("深入理解比特币交易的脚本"),o(r)])]),e("li",null,[e("a",x,[t("比特币智能合约入门（1）"),o(r)])])])])}const k=a(c,[["render",P],["__file","script.html.vue"]]);export{k as default};
