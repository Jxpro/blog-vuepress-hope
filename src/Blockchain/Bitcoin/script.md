---
title: 比特币脚本及交易分析 - 智能合约雏形
shortTitle: 比特币脚本及交易分析
description: 本文重点讨论比特币脚本及交易分析，以及智能合约的雏形。内容包括：图灵不完备，未花费的交易输出(UTXO)，比特币脚本（Script）及虚拟机（BVM），简单交易脚步举例，常见交易脚本验证过程，交易结构，交易输入结构，交易输出结构，智能合约雏形等。
category:
  - Bitcoin
tag:
  - Blockchain
  - Bitcoin
date: 2021-11-29
---

# 比特币脚本及交易分析 - 智能合约雏形

-   大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。 在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。 本文就来分析一下**交易是如何实现可编程的**。

-   当谈及智能合约时，大多数人都会下意识地把比特币排除在讨论范围之外，因为当下流行的观点是比特币不具有智能合约的能力。但是今天想跟大家介绍的内容则正好与此相反：即**比特币从诞生之日即拥有支持智能合约的能力**

## 一、图灵不完备

>   比特币脚本语言**不是图灵完备的**，具有一定的局限性，它**没有循环语句和复杂的条件控制语句**。由于语言存在这种局限性，我们也就没办法使用这种语言写一些死循环或者一些能够导致DOS攻击的恶意代码，从而也就**避免了比特币网络受到DOS攻击**。每一个全节点，都会对交易进行验证。具有这种局限性的脚本语言，使人们无法把这种验证机制看成一个攻击比特币网络的缺陷。

## 二、未花费的交易输出(UTXO)

比特币底层采用了一个很特别的交易模型设计，即 **UTXO（Unspent Transaction Outputs）** 模型。这里我们简单介绍一下，首先来看最基本的交易是如何表示的。

每一个比特币交易主要包括两部分：**输入记录和输出记录**。

每条输出记录主要包括的信息：

-   此输出中包含的比特币数量；
-   一段脚本代码，通常称为**锁定脚本**；

每条输入记录主要包括的信息：

-   对前一个交易输出部分的引用；
-   一段脚本代码，通常称为**解锁脚本**；

>   假设有人已成功发给我一个比特币，那么在链上就存在一条历史交易记录 TX_1。它的输出记录中有一条（记为 `TX_1_OUT_1`）包含了数量为 1 的比特币以及一个只能由我的私钥才能“开启”的“锁”（锁定脚本）。也正是由于这把“锁”的存在，别人才无法使用这个比特币。
>
>   现在我想把这个比特币转给另外一个人，那么需要构建一个新的交易记录 TX_2。它的输入记录中包含了对之前交易输出 `TX_1_OUT_1` 的引用，以及一段由我的私钥签名过的“钥匙”（解锁脚本）；输出记录（记为 `TX_2_OUT_1`）中则包含了比特币数量 1，以及一个只有接收人才能“开启”的“锁”（另一个锁定脚本）。
>
>   这个新的交易 TX_2 被我发送给矿工，且只有通过了矿工对解锁脚本有效性的验证后，这笔交易才会被记录到链上账本中。此时也意味着我完成了一个接收+花费比特币的典型场景。
>
>   此时，输出 `TX_1_OUT_1` 由于被 TX_2 中的输入成功使用，会被系统被标记为已花出。如果尝试利用它再次构建交易，会被矿工认定为“双花”从而拒绝。与之相对，输出 `TX_2_OUT_1` 由于尚未被任何输入使用，故被称为未花费输出（即 UTXO）

比特币的交易都是基于UTXO上的，即**交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入**。

>   挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。
>   UTXO是交易的基本单元，不能再分割。
>   在比特币没有余额概念，只有分散到区块链里的UTXO

随着钱从一个地址被移动到另一个地址的同时**形成了一条所有权链**，像这样：
![own_chain](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-150721.jpeg!wl)

## 三、比特币脚本（Script）及虚拟机（BVM）

比特币底层使用一种名为`Script`的脚本语言来实现“锁”和“钥匙”，它是一种**基于栈的脚本语言**。简单来说，它是一串由操作码（opcode）组成的指令集合，下面是几个简单的操作码例子：（完整的操作码列表请参考[这里](https://wiki.bitcoinsv.io/index.php/Opcodes_used_in_Bitcoin_Script)）

| 操作码   | 描述                                                   |
| -------- | ------------------------------------------------------ |
| OP_2     | 将数值 `2` 推至栈顶                                    |
| OP_ADD   | 将栈顶的两个元素数值相加                               |
| OP_EQUAL | 如果栈顶上2个元素相等，则返回 `true`；否则返回 `false` |

锁定脚本（位于前一个交易的输出中）和解锁脚本（位于当前交易的输入中）都是由其中一些操作码串联组成，每个操作码后面可以有零至两个操作子。

为了验证解锁脚本的有效性，**比特币虚拟机（BVM）**被引入比特币节点。BVM 将锁定脚本连接在解锁脚本的后面，从而形成完整的执行脚本。这个完整的脚本会被 BVM 执行。当执行完毕后，如果栈顶元素的布尔值为 `true`（即数值非零），则认为脚本执行成功，反之其他情况则认为脚本执行失败。

最为常见类型的比特币交易脚本（支付到公钥哈希：**P2PKH（Pay-to-Public-Key-Hash）**）如下：
![script](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151439.jpeg!wl)

## 四、简单交易脚步举例

我们来看个例子。假设在一个交易中，一些比特币被使用以下脚本锁定在输出中：

```script
OP_1 OP_2 OP_ADD OP_EQUAL
```

在另外一个试图花费这个输出的交易中，使用以下脚本：

```script
OP_3
```

为了说明这里的解锁授权是如何进行的，我们来分步模拟一下脚本的执行过程。

-   首先，解锁脚本在前，锁定脚本在后，将两个脚本连接起来形成完整的脚本：

    ```script
    OP_3 OP_1 OP_2 OP_ADD OP_EQUAL
    ```

-   接着，BVM 开始从头执行完整的脚本，具体的步骤如图所示：

![BVM执行过程](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-154148)

最终结束时留在栈顶上的唯一值为 `true`，这说明整个脚本执行成功。如果使用任何不是 `3` 的值作为解锁脚本，则整个脚本的执行结果必然为 `false`，意味着无法成功解锁。

## 五、常见交易脚本验证过程

比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言

>   比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:[比特币脚本](http://www.8btc.com/bitcoin_scripts)

脚本语言通过**从左至右**地处理每个项目的方式执行脚本，下面用两个图说明下常见类型的比特币交易脚本验证执行过程：

-   下图为**解锁脚本**运行过程（主要是**入栈**）
    ![script_run1](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151430.jpeg!wl)
-   下图为**锁定脚本**运行过程（主要是**出栈**)，最后的结果为真，说明交易有效。
    ![script_run2](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151455.jpeg!wl)

## 六、交易分析

### 6.1 交易结构

比特币的交易被设计为可以纳入**多个输入和输出**
![交易结构](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-151808.jpeg!wl)

>   交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示**立即执行**。
>   如果锁定时间不是0并且小于5亿，就被视为**区块高度**，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。
>   如果锁定时间大于5亿，则它被当作是一个**Unix纪元时间戳**（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。

>   交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：**交易费 = 求和（所有输入） - 求和（所有输出）**

### 6.2 交易输入结构

刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：
![输入结构](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152040.jpeg!wl)

我们结合整个交易的结构里看输入结构就是这样子：
![输入结构1](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152048.jpeg!wl)

### 6.3 交易输出结构

刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：
![交易输出结构](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-150709.jpeg!wl)
我们结合整个交易的结构里看输出结构就是这样子：
![交易输出结构1](https://raw.githubusercontent.com/Jxpro/PicBed/master/md/2021/11/07-152102.jpeg!wl)

## 七、智能合约雏形

由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。

比特币的脚本目前常用的主要分为两种：

-   一种是常见的**P2PKH**（支付给公钥哈希）
-   另一种是**P2SH**（Pay-to-Script-Hash支付脚本哈希）

P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。

下面说明一些应用场景，以便大家有更直观的认识。

-   **多重签名应用**
    合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。
-   **保证合同**
    保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。
    一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。
-   **依靠预言**
    假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。
    因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。

## 八、参考文章

-   [比特币脚本及交易分析 - 智能合约雏形](https://learnblockchain.cn/2017/11/10/bitcoin-script/)
-   [深入理解比特币交易的脚本](https://www.infoq.cn/article/deep-understanding-of-bitcoin-transaction-script/)
-   [比特币智能合约入门（1）](https://blog.csdn.net/freedomhero/article/details/106801904)